import unittest
import main


class TestPrimeNumbers(unittest.TestCase):
    """
    Тесты первой функции prime_numbers(low, high)
    В ТЗ не указанно, каким типом данных представлены значения low и high, соответственно он может быть любым.
    Так же не гарантируется что low будет меньше high, сказано лишь, что это границы диапазона.
    Сами границы не должны входить в результат, так как они не входят в диапазон.
    """
    def test_prime_numbers_1(self):
        """
        Исходные данные: '20', 15.
        Ожидаемый результат: [16, 17, 18, 19]
        """
        result = main.prime_numbers('20', 15)
        self.assertEqual(result, [16, 17, 18, 19])

    def test_prime_numbers_2(self):
        """
        Исходные данные: '20', 15
        Ожидаемый результат: [16, 17, 18, 19, 20]
        В отличии от первого теста верхняя граница больше, соответсвенно 20 входит в диапазон.
        """
        result = main.prime_numbers('20.1', 15)
        self.assertEqual(result, [16, 17, 18, 19, 20])

    def test_prime_numbers_3(self):
        """
        Исходные данные: 10, 20.1
        Ожидаемый результат: [16, 17, 18, 19, 20]
        Проверка обработки значения типа float
        """
        result = main.prime_numbers(10, 20.1)
        self.assertEqual(result, [11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

    def test_prime_numbers_4(self):
        """
        Исходные данные: "str", 20.1
        Ожидаемый результат: []
        """
        result = main.prime_numbers("str", 20.1)
        self.assertEqual(result, [])


class TestTextStat(unittest.TestCase):
    def test_text_stat_1(self):
        """
        Исходные данные: 10
        Ожидаемый результат: {'error': str(OSError(9, 'Неверный дескриптор', None, 6, None))}
        При указании некорректного имени файла возвращается словарь с описанием ошибки
        """
        result = main.text_stat(10)
        self.assertEqual(result, {'error': str(OSError(9, 'Неверный дескриптор', None, 6, None))})

    def test_text_stat_2(self):
        """
        Исходные данные: Относительный путь к файлу
        Ожидаемый результат: словарь с заданной статистикой
        При указании некорректного имени файла возвращается словарь с описанием ошибки
        """
        result = main.text_stat("text.txt")
        self.assertEqual(result, {'word_amount': 293, 'paragraph_amount': 8, 'bilingual_word_amount': 3, 'a': (0, 0),
                                  'b': (0, 0), 'c': (1, 1), 'd': (0, 0), 'e': (0, 0), 'f': (0, 0), 'g': (0, 0),
                                  'h': (0, 0), 'i': (0, 0), 'j': (0, 0), 'k': (0, 0), 'l': (0, 0), 'm': (0, 0),
                                  'n': (0, 0), 'o': (0, 0), 'p': (0, 0), 'q': (0, 0), 'r': (1, 1), 's': (0, 0),
                                  't': (0, 0), 'u': (0, 0), 'v': (0, 0), 'w': (0, 0), 'x': (1, 1), 'y': (0, 0),
                                  'z': (3, 2), 'а': (150, 116), 'б': (17, 17), 'в': (96, 82), 'г': (20, 20),
                                  'д': (61, 60), 'е': (222, 155), 'ё': (0, 0), 'ж': (20, 20), 'з': (37, 35),
                                  'и': (190, 150), 'й': (14, 14), 'к': (54, 48), 'л': (90, 87), 'м': (82, 78),
                                  'н': (188, 132), 'о': (199, 135), 'п': (46, 46), 'р': (87, 75), 'с': (144, 111),
                                  'т': (147, 130), 'у': (24, 22), 'ф': (9, 8), 'х': (34, 32), 'ц': (15, 15),
                                  'ч': (35, 35), 'ш': (8, 8), 'щ': (4, 4), 'ъ': (0, 0), 'ы': (50, 48),
                                  'ь': (30, 28), 'э': (18, 18), 'ю': (12, 12), 'я': (43, 41)
                                  })

    def test_text_stat_3(self):
        """
        Исходные данные: абсолютный путь к файлу
        Ожидаемый результат: словарь с заданной статистикой
        При указании некорректного имени файла возвращается словарь с описанием ошибки
        """
        result = main.text_stat(r"C:\Users\Vadim\PycharmProjects\swoyo\text.txt")
        self.assertEqual(result, {'word_amount': 293, 'paragraph_amount': 8, 'bilingual_word_amount': 3, 'a': (0, 0),
                                  'b': (0, 0), 'c': (1, 1), 'd': (0, 0), 'e': (0, 0), 'f': (0, 0), 'g': (0, 0),
                                  'h': (0, 0), 'i': (0, 0), 'j': (0, 0), 'k': (0, 0), 'l': (0, 0), 'm': (0, 0),
                                  'n': (0, 0), 'o': (0, 0), 'p': (0, 0), 'q': (0, 0), 'r': (1, 1), 's': (0, 0),
                                  't': (0, 0), 'u': (0, 0), 'v': (0, 0), 'w': (0, 0), 'x': (1, 1), 'y': (0, 0),
                                  'z': (3, 2), 'а': (150, 116), 'б': (17, 17), 'в': (96, 82), 'г': (20, 20),
                                  'д': (61, 60), 'е': (222, 155), 'ё': (0, 0), 'ж': (20, 20), 'з': (37, 35),
                                  'и': (190, 150), 'й': (14, 14), 'к': (54, 48), 'л': (90, 87), 'м': (82, 78),
                                  'н': (188, 132), 'о': (199, 135), 'п': (46, 46), 'р': (87, 75), 'с': (144, 111),
                                  'т': (147, 130), 'у': (24, 22), 'ф': (9, 8), 'х': (34, 32), 'ц': (15, 15),
                                  'ч': (35, 35), 'ш': (8, 8), 'щ': (4, 4), 'ъ': (0, 0), 'ы': (50, 48),
                                  'ь': (30, 28), 'э': (18, 18), 'ю': (12, 12), 'я': (43, 41)
                                  })


class TestRomanNumeralsToInt(unittest.TestCase):
    def test_roman_numerals_to_int_1(self):
        """
        Исходные данные: римское число CMLXXIV
        Ожидаемый результат: 974
        """
        result = main.roman_numerals_to_int("CMLXXIV")
        self.assertEqual(result, 974)

    def test_roman_numerals_to_int_2(self):
        """
        Исходные данные: римское число C
        Ожидаемый результат: 100
        """
        result = main.roman_numerals_to_int("C")
        self.assertEqual(result, 100)

    def test_roman_numerals_to_int_3(self):
        """
        Исходные данные: c
        Ожидаемый результат: None
        Римские цифры должны указываться в верхнем регистре
        """
        result = main.roman_numerals_to_int("c")
        self.assertEqual(result, None)

    def test_roman_numerals_to_int_4(self):
        """
        Исходные данные: 12CMLXXIV
        Ожидаемый результат: None
        """
        result = main.roman_numerals_to_int("12CMLXXIV")
        self.assertEqual(result, None)


if __name__ == '__main__':
    unittest.main()
